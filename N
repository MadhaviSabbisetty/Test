import axios from "axios";

/**
 * Singleton download handler
 * Keeps Axios request alive even if React component unmounts
 */

let activeController = null;

export const startDownload = async ({
  url,
  payload,
  token,
  onProgress,
  onSuccess,
  onError,
}) => {
  // Prevent multiple parallel downloads
  if (activeController) return;

  const controller = new AbortController();
  activeController = controller;

  try {
    const response = await axios.post(url, payload, {
      responseType: "blob",
      signal: controller.signal,
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      onDownloadProgress: (event) => {
        if (event?.loaded && onProgress) {
          onProgress(event.loaded);
        }
      },
    });

    // Extract filename
    const disposition =
      response.headers["content-disposition"] ||
      response.headers["Content-Disposition"];

    let filename = "report.zip";
    if (disposition) {
      const match = disposition.match(/filename="(.+?)"/);
      if (match) filename = match[1];
    }

    // Trigger browser download
    const blob = new Blob([response.data]);
    const blobUrl = window.URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = blobUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    link.remove();

    window.URL.revokeObjectURL(blobUrl);

    onSuccess?.(filename);
  } catch (error) {
    if (!axios.isCancel(error)) {
      onError?.(error);
    }
  } finally {
    activeController = null;
  }
};




import { startDownload } from "../../utils/downloadManager";






const handleFetchReportData = () => {
  if (!selectedReport || !selectedDate || dateError) return;

  setIsDownloading(true);
  setDownloadedBytes(0);

  const payload = {
    moduleType,
    fileName: selectedReport.fileName,
    branchCode: branch.branchCode,
    date: selectedDate.format("YYYY-MM-DD"),
    roleId: user.role,
  };

  startDownload({
    url: "/RS/reports/download",
    payload,
    token: user?.token, // üî• AUTH HEADER FIX
    onProgress: (bytes) => {
      setDownloadedBytes(bytes);
    },
    onSuccess: (filename) => {
      showSnackBar(
        `Reports "${filename}" downloaded successfully`,
        "success"
      );
      setIsDownloading(false);
      setDownloadedBytes(0);
    },
    onError: () => {
      showSnackBar("Download failed. Please try again.", "error");
      setIsDownloading(false);
      setDownloadedBytes(0);
    },
  });
};


here√©e√©eeeeeeere--------------------------------

import React, { createContext, useContext, useRef, useState } from "react";
import axios from "axios";

const DownloadContext = createContext(null);

export const DownloadProvider = ({ children }) => {
  const controllerRef = useRef(null);

  const [isDownloading, setIsDownloading] = useState(false);
  const [downloadedBytes, setDownloadedBytes] = useState(0);

  const startDownload = async ({
    url,
    payload,
    token,
    onSuccess,
    onError,
  }) => {
    if (isDownloading) return;

    const controller = new AbortController();
    controllerRef.current = controller;

    try {
      setIsDownloading(true);
      setDownloadedBytes(0);

      const response = await axios.post(url, payload, {
        responseType: "blob",
        signal: controller.signal,
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        onDownloadProgress: (e) => {
          if (e?.loaded) {
            setDownloadedBytes(e.loaded);
          }
        },
      });

      // ‚¨áÔ∏è IMPORTANT: only NOW trigger browser save
      const disposition =
        response.headers["content-disposition"] ||
        response.headers["Content-Disposition"];

      let filename = "report.zip";
      if (disposition) {
        const match = disposition.match(/filename="(.+?)"/);
        if (match) filename = match[1];
      }

      const blobUrl = window.URL.createObjectURL(response.data);
      const link = document.createElement("a");
      link.href = blobUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(blobUrl);

      onSuccess?.(filename);
    } catch (err) {
      if (!axios.isCancel(err)) {
        onError?.(err);
      }
    } finally {
      setIsDownloading(false);
      setDownloadedBytes(0);
      controllerRef.current = null;
    }
  };

  return (
    <DownloadContext.Provider
      value={{
        startDownload,
        isDownloading,
        downloadedBytes,
      }}
    >
      {children}
    </DownloadContext.Provider>
  );
};

export const useDownload = () => useContext(DownloadContext);


const { startDownload, isDownloading, downloadedBytes } = useDownload();


const handleFetchReportData = () => {
  if (!selectedReport || !selectedDate || dateError) return;

  startDownload({
    url: "/RS/reports/download",
    payload: {
      moduleType,
      fileName: selectedReport.fileName,
      branchCode: branch.branchCode,
      date: selectedDate.format("YYYY-MM-DD"),
      roleId: user.role,
    },
    token: user.token,
    onSuccess: (filename) => {
      showSnackBar(`"${filename}" downloaded successfully`, "success");
    },
    onError: () => {
      showSnackBar("Download failed", "error");
    },
  });
};














import React, { createContext, useContext, useRef, useState } from "react";
import axios from "axios";

/* 1Ô∏è‚É£ Create the context */
const DownloadContext = createContext(null);

/* 2Ô∏è‚É£ Provider */
export const DownloadProvider = ({ children }) => {
  const controllerRef = useRef(null);

  const [isDownloading, setIsDownloading] = useState(false);
  const [downloadedBytes, setDownloadedBytes] = useState(0);

  const startDownload = async ({
    url,
    payload,
    token,
    onSuccess,
    onError,
  }) => {
    if (isDownloading) return;

    const controller = new AbortController();
    controllerRef.current = controller;

    try {
      setIsDownloading(true);
      setDownloadedBytes(0);

      const response = await axios.post(url, payload, {
        responseType: "blob",
        signal: controller.signal,
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        onDownloadProgress: (e) => {
          if (e?.loaded) {
            setDownloadedBytes(e.loaded);
          }
        },
      });

      const disposition =
        response.headers["content-disposition"] ||
        response.headers["Content-Disposition"];

      let filename = "report.zip";
      if (disposition) {
        const match = disposition.match(/filename="(.+?)"/);
        if (match) filename = match[1];
      }

      const blobUrl = window.URL.createObjectURL(response.data);
      const link = document.createElement("a");
      link.href = blobUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(blobUrl);

      onSuccess?.(filename);
    } catch (err) {
      if (!axios.isCancel(err)) {
        onError?.(err);
      }
    } finally {
      setIsDownloading(false);
      setDownloadedBytes(0);
      controllerRef.current = null;
    }
  };

  return (
    <DownloadContext.Provider
      value={{ startDownload, isDownloading, downloadedBytes }}
    >
      {children}
    </DownloadContext.Provider>
  );
};

/* 3Ô∏è‚É£ Hook (THIS is what you import) */
export const useDownload = () => {
  const context = useContext(DownloadContext);
  if (!context) {
    throw new Error(
      "useDownload must be used inside a DownloadProvider"
    );
  }
  return context;
};


























 <Box sx={styles.buttonContainer}>
                <Button
                  sx={styles.downloadButton}
                  endIcon={<CloudDownloadTwoTone />}
                  variant="contained"
                  onClick={handleFetchReportData}
                  disabled={
                    disableInputs ||
                    !selectedReport ||
                    !selectedDate ||
                    !!dateError
                  }
                >
                  {isDownloading ? "Downloading..." : "Fetch & Download"}
                </Button>

                <Fade in={isDownloading} unmountOnExit>
                  <Box sx={styles.progressContainer}>
                    <Box sx={styles.progressHeader}>
                      <Box sx={styles.progressIconWrapper}>
                        <CloudDownloadTwoTone sx={styles.innerDownloadIcon} />
                      </Box>
                      <Box sx={styles.progressHeaderTextBox}>
                        <Typography variant="body2" fontWeight={600}>
                          Searching{" "}
                          {selectedReport?.reportName ?? "the selected report"}{" "}
                          for the period{" "}
                          {selectedDate?.isValid()
                            ? selectedDate.format("YYYY-MM-DD")
                            : "an unknown period"}{" "}
                          is in progress.
                        </Typography>

                        <Typography
                          variant="caption"
                          color="text.secondary"
                          sx={styles.progressCaption}
                        >
                          {downloadedMB
                            ? `Streaming report data‚Ä¶ ${downloadedMB} MB received`
                            : "Preparing your report stream‚Ä¶"}
                        </Typography>
                      </Box>

                      {downloadedMB && (
                        <CustomChip
                          color="error"
                          label={`${downloadedMB} MB downloaded`}
                          variant="filled"
                        />
                      )}
                    </Box>
                    <LinearProgress
                      variant="indeterminate"
                      sx={styles.progressBar}
                    />
                  </Box>
                </Fade>
              </Box>
