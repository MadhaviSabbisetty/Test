commonmasterservice

commonmastercontroller.java
package com.tcs.fincore.CommonMasterService.Controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.tcs.fincore.CommonMasterService.dto.ApiResponse;
import com.tcs.fincore.CommonMasterService.dto.BranchDto;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CircleDto;
import com.tcs.fincore.CommonMasterService.dto.SearchRequest;
import com.tcs.fincore.CommonMasterService.dto.ZoneDto;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.FileType;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.service.CommonMasterService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping("/api/common-master")
public class CommonMasterController {

    private final CommonMasterService service;

    @GetMapping("/segment-codes")
    public List<SegmentCodeMaster> getSegmentCodes(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Segment Codes");
        return service.getSegmentCodes();
    }

    @PostMapping("/cgls")
    public PaginatedResponseDto<?> getCGLs(
            @RequestHeader("Authorization") String authorizationHeader,
            @RequestHeader("X-Request-Type") String requestType,
            @RequestBody SearchRequest request) {
        log.info("Received request to fetch all CGLs");
        return service.searchAnyMaster(requestType, request);
    }

    @GetMapping("/cgl-code-description-only")
    public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(@RequestParam String q) {
        log.info("Received request to fetch all CGL Code descriptions");
        return service.getCGLsCodeDescriptionOnly(q);
    }

    @GetMapping("/cgl-codes")
    public List<String> getCGLCodes(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all CGL Codes");
        return service.getCGLCodes();
    }

    @GetMapping("/states")
    public List<StateMaster> getStateList(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all States");
        return service.getStateList();
    }

    @GetMapping("/branches")
    public List<BranchMaster> getBranches(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Branches");
        return service.getBranches();
    }

    @GetMapping("/branches-code-name-only")
    public List<BranchCodeNameOnly> getBranchesCodeNameOnly(@RequestParam String q) {
        log.info("Received request to fetch all Branch Code names");
        return service.getBranchesCodeNameOnly(q);
    }

    @GetMapping("/zone-codes")
    public List<ZoneMaster> getZoneCodes() {
        log.info("Received request to fetch all Zone Codes");
        return service.getZoneCodes();
    }

    @GetMapping("/circle-codes")
    public List<CircleMaster> getCircleList() {
        log.info("Received request to fetch all Circle Codes");
        return service.getCircleList();
    }

    @GetMapping("/currency-master")
    public List<CurrencyMasterModel> getCurrency(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Currencies from Currency Master");
        return service.getCurrency();
    }

    @GetMapping("/currency-code-name-only")
    public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly(
            @RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Currency Code names");
        return service.getCurrencyCodeNameOnly();
    }

    @GetMapping("/currency")
    public List<String> getCurrencies(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Currency");
        return service.getCurrencies();
    }

    @GetMapping("/calendar-configuration")
    public CalenderConfigModel getCalenderConfig(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Calender Configurations");
        return service.getCalenderConfig();
    }

    @GetMapping("/currency-rate-change")
    public List<CurrencyRateChange> getRateChange(@RequestHeader("Authorization") String authorizationHeader) {
        log.info("Received request to fetch all Currency rate change");
        return service.getRateChange();
    }

    @PostMapping("/branches-master")
    public PaginatedResponseDto<?> getBranchNames(@RequestHeader("Authorization") String authorizationHeader,
                                                  @RequestHeader("X-Request-Type") String requestType,
                                                  @RequestBody SearchRequest request) {
        log.info("Received request to Search in Master table for {}.", requestType);
        return service.searchAnyMaster(requestType, request);
    }

    /**
     * Api end point for ViewCgl
     * @author Jailabdin [v1023042]
     * @since 2025-12-08
     */
    @GetMapping("/view-cgl")
    public ResponseEntity<ApiResponse<PaginatedResponseDto<CGLSegmentResponseDTO>>> searchCglWithSegment(
            @RequestParam String cglCodeOrDesc, @RequestParam(required = false) Integer page,
            @RequestParam(required = false) Integer size) {
        log.info("Received request to view paginated CGL details.");
        PaginatedResponseDto<CGLSegmentResponseDTO> result = service.searchCglWithSegment(cglCodeOrDesc, page, size);

        return ResponseEntity.ok(ApiResponse.success(result, "CGL Details fetched Successfully"));
    }

    /**
     * Api end point for ViewBranchDetails
     * @author Jailabdin [v1023042]
     * @since 2025-12-08
     */
    @GetMapping("/view-branch")
    public ResponseEntity<ApiResponse<List<BranchStateCircleResponseDTO>>> searchByBranchNameORCode(
            @RequestParam String branchCodeOrName) {
        log.info("Received request to view Branch details");
        List<BranchStateCircleResponseDTO> result = service.searchByBranchNameORCode(branchCodeOrName);
        return ResponseEntity.ok(ApiResponse.success(result, "Branch Details Fetched Successfully"));
    }


    /**
     * Checks if a branch exists.
     * Endpoint: GET /branches-check?code=BR001
     */
    @GetMapping("/branches-check")
    public ResponseEntity<?> checkBranch(@RequestParam(name = "code") String branchCode) {
        log.info("Received request to check branch : {} exist or not", branchCode);

        try {
            boolean exists = service.isBranchCodeExists(branchCode);
            // Return structured JSON response
            return ResponseEntity.ok(Map.of(
                    "exists", exists,
                    "message", exists ? "Branch code found" : "Branch code available/not found",
                    "code", branchCode
            ));
        } catch (IllegalArgumentException e) {
            // Handle invalid input (400 Bad Request)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(Map.of("error", e.getMessage()));
        } catch (Exception e) {
            // Handle unexpected errors (500 Internal Server Error)
            log.error("Error checking branch: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "An unexpected error occurred"));
        }
    }


    //---------------------------------------------------------------------------------------
    //--------------------  Apis for branch wise report download screen ---------------------
    //---------------------------------------------------------------------------------------
    // Zones (INDIAN only)
    @GetMapping("/indian-zones")
    public List<ZoneDto> getZones() {
        log.info("Received request to fetch all Indian zones");
        return service.getZones();
    }
 
    // Circles (INDIAN / FOREIGN)
    @GetMapping("/indian-foreign-circles")
    public List<CircleDto> getCircles(
            @RequestParam String bankType,
            @RequestParam(required = true) String zoneCode) {
        log.info("Received request to fetch {} circles", bankType);
        return service.getCircles(bankType, zoneCode);
    }
 
       // Branches
    @GetMapping("/indian-foreign-branches")
    public PaginatedResponseDto<BranchDto> getAllBranches(
            @RequestParam String circleCode, Integer page, Integer size) {
        log.info("Received request to fetch branches under circle code: {}", circleCode);
        return service.getAllBranches(circleCode,page,size);
    }

    /*To get data from File_Type_Master */
    @GetMapping("/files")
    public List<FileType> getFileTypes(){
        return service.getFileTypes();
    }
}

commonmasterservice.java

package com.tcs.fincore.CommonMasterService.service;

import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import com.tcs.fincore.CommonMasterService.dto.BalanceRequestDTO;
import com.tcs.fincore.CommonMasterService.dto.BalanceResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.BranchDto;
import com.tcs.fincore.CommonMasterService.dto.BranchStateCircleResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CGLSegmentResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CalenderConfigResponseDTO;
import com.tcs.fincore.CommonMasterService.dto.CircleDto;
import com.tcs.fincore.CommonMasterService.dto.SearchRequest;
import com.tcs.fincore.CommonMasterService.dto.ZoneDto;
import com.tcs.fincore.CommonMasterService.dto.PaginatedResponseDto;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.BranchMasterWithCircleState;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMaster;
import com.tcs.fincore.CommonMasterService.model.CGLMasterWithSegment;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.FileType;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;

public interface CommonMasterService {

	List<SegmentCodeMaster> getSegmentCodes();

	List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(String query);

	List<String> getCGLCodes();

	List<StateMaster> getStateList();

	List<BranchMaster> getBranches();

	List<BranchCodeNameOnly> getBranchesCodeNameOnly(String query);

	List<ZoneMaster> getZoneCodes();

	List<CircleMaster> getCircleList();

	List<CurrencyMasterModel> getCurrency();

	List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly();

	List<CurrencyRateChange> getRateChange();

	List<String> getCurrencies();

	CalenderConfigModel getCalenderConfig();

	PaginatedResponseDto<BalanceResponseDTO> getBalanceDetails(BalanceRequestDTO request);

	byte[] exportBalanceToExcel(BalanceRequestDTO request);

	Page<BranchMaster> getBranchNames(Pageable pageable);

	PaginatedResponseDto<CGLSegmentResponseDTO> searchCglWithSegment(String text, Integer page, Integer size);

	CGLSegmentResponseDTO toCGLDto(CGLMasterWithSegment c);

	List<BranchStateCircleResponseDTO> searchByBranchNameORCode(String name);

	BranchStateCircleResponseDTO toBranchDto(BranchMasterWithCircleState b);

	boolean isBranchCodeExists(String branchCode);

	PaginatedResponseDto<?> searchAnyMaster(String requestType,SearchRequest request);

	List<ZoneDto> getZones();

	List<CircleDto> getCircles(String bankType, String zoneCode);

	PaginatedResponseDto<BranchDto> getAllBranches(String circleCode , Integer page, Integer size);

	List<FileType> getFileTypes();


}


commonmasterserviceimpl.java

package com.tcs.fincore.CommonMasterService.service;

import com.tcs.fincore.CommonMasterService.dto.*;
import com.tcs.fincore.CommonMasterService.exception.NoDataFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.tcs.fincore.CommonMasterService.Specification.GenericSpecification;
import com.tcs.fincore.CommonMasterService.enums.MasterType;
import com.tcs.fincore.CommonMasterService.model.BalanceRecord;
import com.tcs.fincore.CommonMasterService.model.BranchCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.BranchMaster;
import com.tcs.fincore.CommonMasterService.model.BranchMasterWithCircleState;
import com.tcs.fincore.CommonMasterService.model.CGLCodeDescriptionOnly;
import com.tcs.fincore.CommonMasterService.model.CGLMasterWithSegment;
import com.tcs.fincore.CommonMasterService.model.CalenderConfigModel;
import com.tcs.fincore.CommonMasterService.model.CircleMaster;
import com.tcs.fincore.CommonMasterService.model.CurrencyCodeNameOnly;
import com.tcs.fincore.CommonMasterService.model.CurrencyMasterModel;
import com.tcs.fincore.CommonMasterService.model.CurrencyRateChange;
import com.tcs.fincore.CommonMasterService.model.FileType;
import com.tcs.fincore.CommonMasterService.model.SegmentCodeMaster;
import com.tcs.fincore.CommonMasterService.model.StateMaster;
import com.tcs.fincore.CommonMasterService.model.ZoneMaster;
import com.tcs.fincore.CommonMasterService.repository.BalanceRecordRepository;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.BranchMasterWithStateCircleRepository;
import com.tcs.fincore.CommonMasterService.repository.CGLMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CGLMasterWithSegmentRepository;
import com.tcs.fincore.CommonMasterService.repository.CalenderConfigRepository;
import com.tcs.fincore.CommonMasterService.repository.CircleMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CurrencyMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.CurrencyRateChangeRepo;
import com.tcs.fincore.CommonMasterService.repository.FileTypeRepository;
import com.tcs.fincore.CommonMasterService.repository.SegmentCodeMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.StateMasterRepository;
import com.tcs.fincore.CommonMasterService.repository.ZoneMasterRepository;
import com.tcs.fincore.CommonMasterService.resolver.MasterResolver;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class CommonMasterServiceImpl implements CommonMasterService {

	private static final int EXPORT_CHUNK_SIZE = 500;
	private static final String ZONE_IST = "Asia/Kolkata";

	private final SegmentCodeMasterRepository repository;
	private final CGLMasterRepository cglMasterRepository;
	private final StateMasterRepository stateMasterRepository;
	private final BranchMasterRepository branchMasterRepository;
	private final ZoneMasterRepository zoneMasterRepository;
	private final CircleMasterRepository circleMasterRepository;
	private final CurrencyMasterRepository currencyMasterRepo;
	private final CalenderConfigRepository calenderConfigRepository;
	private final CurrencyRateChangeRepo currencyRateChangeRepo;
	private final BalanceRecordRepository balanceRecordRepository;
	private final CGLMasterWithSegmentRepository cglWithSegmentRepository;
	private final BranchMasterWithStateCircleRepository branchMasterWithStateCircleRepository;
	private final FileTypeRepository fileTypeRepo;
	private final MasterResolver resolver;

	@Override
	public List<SegmentCodeMaster> getSegmentCodes() {
		return (List<SegmentCodeMaster>) repository.findAll();
	}

	@Override
	public List<CGLCodeDescriptionOnly> getCGLsCodeDescriptionOnly(String query) {
		return cglMasterRepository.findBycglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(query, query);
	}

	@Override
	public List<String> getCGLCodes() {
		return cglMasterRepository.findAllCGLNumbers();
	}

	@Override
	public List<String> getCurrencies() {
		return currencyMasterRepo.findAllCurrency();
	}

	@Override
	public List<StateMaster> getStateList() {
		return (List<StateMaster>) stateMasterRepository.findAll();
	}

	@Override
	public List<BranchMaster> getBranches() {
		return (List<BranchMaster>) branchMasterRepository.findAll();
	}

	@Override
	public List<BranchCodeNameOnly> getBranchesCodeNameOnly(String query) {
		return branchMasterRepository.findTop100ByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(query, query);
	}

	@Override
	public List<ZoneMaster> getZoneCodes() {
		return zoneMasterRepository.findAll();
	}

	@Override
	public List<CircleMaster> getCircleList() {
		return circleMasterRepository.findAll();
	}

	@Override
	public List<CurrencyMasterModel> getCurrency() {
		return (List<CurrencyMasterModel>) currencyMasterRepo.findAll();
	}

	@Override
	public List<CurrencyCodeNameOnly> getCurrencyCodeNameOnly() {
		return currencyMasterRepo.findAllBy();
	}

	@Override
	public CalenderConfigModel getCalenderConfig() {
		return calenderConfigRepository.findByActiveFlag(1);
	}

	@Override
	public List<CurrencyRateChange> getRateChange() {
		return (List<CurrencyRateChange>) currencyRateChangeRepo.findAll();
	}

	@Override
	public PaginatedResponseDto<BalanceResponseDTO> getBalanceDetails(BalanceRequestDTO request) {
		if (request.getEndDate().before(request.getStartDate())) {
			log.error("End date must be after start date.");
			throw new IllegalArgumentException("End date must be after start date");
		}

		// 1. Force Start Date to 00:00:00 IST
		Date adjustedStartDate = convertToStartOfDay(request.getStartDate());
		// 2. Force End Date to 23:59:59 IST
		Date adjustedEndDate = convertToEndOfDay(request.getEndDate());

		int page = (request.getPage() != null && request.getPage() >= 0) ? request.getPage() : 0;
		int size = (request.getSize() != null && request.getSize() >= 0) ? request.getSize() : 10;

		String sortIn = (request.getSortIn() != null && !request.getSortIn().isBlank())
				? request.getSortIn().toUpperCase()
				: "ASC";

		Sort sort = sortIn.equals("DESC") ? Sort.by("date").descending() : Sort.by("date").ascending();
		PageRequest pageRequest = PageRequest.of(page, size, sort);

		log.info("Adjusted Start Date : {}", adjustedStartDate);
		log.info("Adjusted End Date : {}", adjustedEndDate);

		Page<BalanceRecord> records = balanceRecordRepository.findByBranchAndCglAndCurrencyAndDateBetween(
				request.getBranch(), request.getCgl(), request.getCurrency(),
				adjustedStartDate, adjustedEndDate,
				pageRequest);

		if (records.isEmpty()) {
			log.warn("No records found for the given filters.");
			throw new NoDataFoundException("No records found for given filters");
		}

		List<BalanceResponseDTO> list = records.stream()
				.map(r -> new BalanceResponseDTO(
						r.getId(), r.getDate(), r.getBranch(), r.getCgl(), r.getCurrency(), r.getBalance()))
				.toList();

		String actualSort = records.getSort().stream().findFirst().map(order -> order.getDirection().name())
				.orElse("UNSORTED");

		return new PaginatedResponseDto<>(
				records.getNumber(), records.getTotalPages(), records.getSize(), records.getTotalElements(), actualSort,
				list);
	}

	@Override
	public byte[] exportBalanceToExcel(BalanceRequestDTO request) {

		if (request.getEndDate().before(request.getStartDate())) {
			throw new IllegalArgumentException("End date must be after start date");
		}

		// Adjusted dates
		Date adjustedStartDate = convertToStartOfDay(request.getStartDate());
		Date adjustedEndDate = convertToEndOfDay(request.getEndDate());

		try (Workbook workbook = new XSSFWorkbook();
				ByteArrayOutputStream out = new ByteArrayOutputStream()) {
			Sheet sheet = workbook.createSheet("Balance Enquiry");

			CellStyle headerStyle = workbook.createCellStyle();
			Font headereFont = workbook.createFont();
			headereFont.setBold(true);
			headerStyle.setFont(headereFont);

			CellStyle dateStyle = workbook.createCellStyle();
			CreationHelper creationHelper = workbook.getCreationHelper();
			short dateFormat = creationHelper.createDataFormat().getFormat("dd-MM-yyyy");
			dateStyle.setDataFormat(dateFormat);

			CellStyle balanceStyle = workbook.createCellStyle();
			short balanceFormat = creationHelper.createDataFormat().getFormat("#,##0.00");
			balanceStyle.setDataFormat(balanceFormat);

			String[] columns = { "ID", "Date", "Branch", "CGL", "Currency", "Balance" };
			Row header = sheet.createRow(0);
			for (int i = 0; i < columns.length; i++) {
				Cell cell = header.createCell(i);
				cell.setCellValue(columns[i]);
				cell.setCellStyle(headerStyle);
			}

			int rowIdx = 1;
			int page = 0;
			Page<BalanceRecord> recordsPage;

			do {
				Pageable pageable = PageRequest.of(page, EXPORT_CHUNK_SIZE, Sort.by("date").ascending());

				recordsPage = balanceRecordRepository.findByBranchAndCglAndCurrencyAndDateBetween(
						request.getBranch(),
						request.getCgl(),
						request.getCurrency(),
						adjustedStartDate,
						adjustedEndDate,
						pageable);

				if (page == 0 && recordsPage.isEmpty()) {
					workbook.write(out);
					return out.toByteArray();
				}

				for (BalanceRecord r : recordsPage.getContent()) {
					Row row = sheet.createRow(rowIdx++);
					if (r.getId() != null) {
						row.createCell(0).setCellValue(r.getId());
					} else {
						row.createCell(0).setCellValue("");
					}
					Cell dateCell = row.createCell(1);
					if (r.getDate() != null) {
						dateCell.setCellValue(r.getDate());
						dateCell.setCellStyle(dateStyle);
					} else {
						dateCell.setCellValue("");
					}

					row.createCell(2).setCellValue(r.getBranch() != null ? r.getBranch() : "");
					row.createCell(3).setCellValue(r.getCgl() != null ? r.getCgl() : "");
					row.createCell(4).setCellValue(r.getCurrency() != null ? r.getCurrency() : "");
					Cell balanceCell = row.createCell(5);
					balanceCell.setCellValue(r.getBalance());
					balanceCell.setCellStyle(balanceStyle);
				}
				page++;
			} while (!recordsPage.isLast());

			for (int i = 0; i < columns.length; i++) {
				sheet.autoSizeColumn(i);
			}
			workbook.write(out);
			return out.toByteArray();

		} catch (IOException e) {
			throw new RuntimeException("Failed to generate Excel file", e);
		}
	}

	@Override
	public Page<BranchMaster> getBranchNames(Pageable pageable) {

		return branchMasterRepository.findAll(pageable);
	}

	@Override
	@Transactional
	public PaginatedResponseDto<CGLSegmentResponseDTO> searchCglWithSegment(String text, Integer page, Integer size) {
		int pageNo = (page == null || page < 0) ? 0 : page;
		int pageSize = (size == null || size <= 0) ? 10 : size;

		Pageable pageable = PageRequest.of(pageNo, pageSize);

		Page<CGLMasterWithSegment> pageResult = cglWithSegmentRepository
				.findByCglNumberContainingIgnoreCaseOrDescriptionContainingIgnoreCase(text.trim(), text.trim(),
						pageable);

		List<CGLSegmentResponseDTO> list = pageResult.getContent().stream().map(this::toCGLDto).toList();
		if (list.isEmpty()) {
			throw new NoDataFoundException("No records found for " + text + " !!");
		}
		return new PaginatedResponseDto<>(pageResult.getNumber(), pageResult.getTotalPages(), pageResult.getSize(),
				pageResult.getTotalElements(), null, list);

	}

	// Helper Class for searchCglWithSegment to convert entity to DTO
	public CGLSegmentResponseDTO toCGLDto(CGLMasterWithSegment c) {
		return new CGLSegmentResponseDTO(c.getCglNumber(), c.getDescription(), c.getComp1(), c.getComp2(),
				c.getAcClassification(), c.getSegmentCode(),
				(c.getSegment() != null ? c.getSegment().getDescription() : null), c.getBalFwd(), c.getDefBalType(),
				c.getStatus(), c.getOpenDate(), c.getCloseDate(), c.getBalCompare(), c.getManualPosting());
	}

	public List<BranchStateCircleResponseDTO> searchByBranchNameORCode(String name) {

		List<BranchMasterWithCircleState> branches = branchMasterWithStateCircleRepository
				.findByCodeContainingIgnoreCaseOrNameContainingIgnoreCase(name.trim(), name.trim());

		if (branches.isEmpty()) {
			throw new NoDataFoundException("No branches found for " + name + " !!");
		}

		return branches.stream().map(this::toBranchDto).toList();

	}

	// Helper Class for searchByBranchNameORCode to convert entity to DTO
	public BranchStateCircleResponseDTO toBranchDto(BranchMasterWithCircleState b) {
		return new BranchStateCircleResponseDTO(b.getCode(), b.getName(), b.getCity(), b.getCircleCode(),
				(b.getCircle() != null ? b.getCircle().getCircleName() : null), b.getStateCode(),
				(b.getState() != null ? b.getState().getStateName() : null), b.getAddress(), b.getPinCode(),
				b.getPhoneNumber(), b.getEmailId(), b.getNmrCode(), b.getStatus(), b.getOpenDate(), b.getCloseDate(),
				b.getMergeDate(), b.getMergedWithBranch(), b.getLastChangeDate(), b.getCpcFlag(), b.getFoodCreditFlag(),
				b.getCurrChestFlag(), b.getBranchType());
	}

	public boolean isBranchCodeExists(String branchCode) {
		// if (branchCode == null || branchCode.isEmpty()) {
		// return false;
		// }
		Optional<BranchMaster> result = branchMasterRepository.findById(branchCode);
		if (result.isPresent()) {
			log.info("Branch {} already exist!", branchCode);
			return true;
		}
		return false;
	}

	@Override
	public PaginatedResponseDto<?> searchAnyMaster(String requestType, SearchRequest request) {
		MasterType masterType;
		try {
			masterType = MasterType.valueOf(requestType.toUpperCase());
		} catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("Invalid X-Request-Type: " + requestType);
		}

		JpaSpecificationExecutor<?> repo = resolver.resolve(masterType);

		PageRequest pageRequest;

		if (request.getSortField() != null && request.getSortOrder() != null) {
			Sort.Direction direction = Sort.Direction.fromString(request.getSortOrder());
			pageRequest = PageRequest.of(request.getPage(), request.getSize(),
					Sort.by(direction, request.getSortField()));
		} else {
			pageRequest = PageRequest.of(request.getPage(), request.getSize());
		}
		Page<?> page = repo.findAll(
				GenericSpecification.build(request.getFilters()),
				pageRequest);

		PaginatedResponseDto<Object> response = new PaginatedResponseDto<>();
		response.setData(page.getContent());
		response.setCurrentPage(page.getNumber());
		response.setPageSize(page.getSize());
		response.setTotalPages(page.getTotalPages());
		response.setTotalElements(page.getTotalElements());

		return response;
	}

	/**
	 * Helper Method: Forces the date to Start of Day (00:00:00) in Asia/Kolkata
	 * regardless of Server TimeZone.
	 */
	private Date convertToStartOfDay(Date date) {
		if (date == null)
			return null;
		// Use Calendar with Specific TimeZone to avoid UTC shifts
		Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(ZONE_IST));
		calendar.setTime(date);
		calendar.set(Calendar.HOUR_OF_DAY, 0);
		calendar.set(Calendar.MINUTE, 0);
		calendar.set(Calendar.SECOND, 0);
		calendar.set(Calendar.MILLISECOND, 0);
		return calendar.getTime();
	}

	/**
	 * Helper Method: Forces the date to End of Day (23:59:59) in Asia/Kolkata
	 * regardless of Server TimeZone.
	 */
	private Date convertToEndOfDay(Date date) {
		if (date == null)
			return null;
		// Use Calendar with Specific TimeZone to avoid UTC shifts
		Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(ZONE_IST));
		calendar.setTime(date);
		calendar.set(Calendar.HOUR_OF_DAY, 23);
		calendar.set(Calendar.MINUTE, 59);
		calendar.set(Calendar.SECOND, 59);
		calendar.set(Calendar.MILLISECOND, 999);
		return calendar.getTime();
	}

	@Override
	public List<ZoneDto> getZones() {
		return zoneMasterRepository.findIndianZones().stream()
				.map(z -> new ZoneDto(z.getId(), z.getDescription()))
				.toList();
	}

	@Override
	public List<CircleDto> getCircles(String bankType, String zoneCode) {

		String finalZoneCode = "Foreign Office".equalsIgnoreCase(bankType)
				? zoneMasterRepository.findForeignZones()
				: zoneCode;

		return circleMasterRepository.findByZoneCodes(finalZoneCode).stream()
				.map(c -> new CircleDto(c.getCircleCode(), c.getCircleName()))
				.toList();
	}

	@Override
	public PaginatedResponseDto<BranchDto> getAllBranches(String circleCode, Integer page, Integer size) {

		int pageNo = (page == null || page < 0) ? 0 : page;
		int pageSize = (size == null || size <= 0) ? 20 : size;

		Pageable pageable = PageRequest.of(pageNo, pageSize);

		Page<BranchMaster> pageResult = branchMasterRepository.findByCircleCodes(circleCode, pageable);
		List<BranchDto> list = pageResult.stream().map(r -> new BranchDto(r.getCode(), r.getName())).toList();
		return new PaginatedResponseDto<>(pageResult.getNumber(), pageResult.getTotalPages(), pageResult.getSize(),
				pageResult.getTotalElements(), "ASC", list);
	}

	@Override
	public List<FileType> getFileTypes() {

		return fileTypeRepo.findAll(Sort.by("type").and(Sort.by("stream").descending()));
	}
}


securityconfig.java

package com.tcs.fincore.CommonMasterService.config;


import com.fincore.commonutilities.config.CommonSecurityConfig;
import com.fincore.commonutilities.config.RedisConfig;
import com.fincore.commonutilities.jwt.JwtUtil;
import com.fincore.commonutilities.logging.MdcLoggingFilter;
import com.fincore.commonutilities.security.ContextRbacFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;


/**
 * Common Security Configuration.
 * * Aligned with the "Distributed Gateway" architecture.
 * It uses the ContextRbacFilter from Common Utilities to enforce:
 * 1. Token Validity
 * 2. Single Session (Redis check)
 * 4. Centralised Mdc Logging Filter
 * 3. RBAC Permissions
 */
@Configuration
@EnableWebSecurity
@Import({RedisConfig.class, JwtUtil.class, CommonSecurityConfig.class}) // Don't import Filters here if you define them as Beans below
public class SecurityConfig {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CommonSecurityConfig commonSecurityConfig;

    // --- 1. Define Filters as Beans (Explicitly) ---

    @Bean
    public MdcLoggingFilter mdcLoggingFilter() {
        return new MdcLoggingFilter(jwtUtil);
    }

    @Bean
    public ContextRbacFilter contextRbacFilter() {
        return new ContextRbacFilter(redisTemplate, jwtUtil);
    }

    // --- 2. Prevent Global Registration ---
    // This stops "The Filter class ... does not have a registered order" error

    @Bean
    public FilterRegistrationBean<MdcLoggingFilter> mdcFilterRegistration(MdcLoggingFilter filter) {
        FilterRegistrationBean<MdcLoggingFilter> registration = new FilterRegistrationBean<>(filter);
        registration.setEnabled(false); // Disable global chain
        return registration;
    }

    @Bean
    public FilterRegistrationBean<ContextRbacFilter> rbacFilterRegistration(ContextRbacFilter filter) {
        FilterRegistrationBean<ContextRbacFilter> registration = new FilterRegistrationBean<>(filter);
        registration.setEnabled(false); // Disable global chain
        return registration;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .cors(cors -> cors.configurationSource(commonSecurityConfig.corsConfigurationSource()))
                .sessionManagement(s -> s.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/actuator/**", "/api/auth/**", "/error").permitAll()
                        .anyRequest().authenticated()
                )
                // Add Filters using the BEAN references (methods above)
                .addFilterBefore(mdcLoggingFilter(), UsernamePasswordAuthenticationFilter.class)
                .addFilterAfter(contextRbacFilter(), MdcLoggingFilter.class);

        return http.build();
    }
}
