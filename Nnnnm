import { useEffect, useRef, useState, useCallback } from "react";
import { fetchEventSource } from "@microsoft/fetch-event-source";
import { useDispatch, useSelector } from "react-redux";
import { resolveConfig } from "../config/EnvironmentConfig";

import { logoutSuccess } from "../store/slices/authSlice";
import { parseJwt } from "../utils/EncryptionUtilities";
import api from "../config/axiosConfig";
import { refreshAccessToken } from "../utils/AuthHelpers";

const useStreamApi = () => {
  const dispatch=useDispatch();
  const token = useSelector((state) => state.auth.token);

  const controllerRef = useRef(null);
  const [connected, setConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  const retryRef=useRef(false);


  // const refreshAccessToken=async()=>
  //   {
  //     const response=await api.post(
  //       `${resolveConfig("/LS") || ""}/auth/refresh-token`
  //     );
  //     const accessToken=
  //     response?.data?.data?.accessToken;
  //     if(!accessToken)throw new Error("No access token returned");

  //     const user=parseJwt(accessToken);
  //     dispatch(tokenRefreshed({token:accessToken,user}));
  //     return accessToken;
  //   }

  const startStream = useCallback(
    (url, { onMessage, onOpen, onError, onTaskProgress } = {}) => {
      if (!token) return console.warn("No token, cannot start SSE stream");
      const parts = url.split("/");
      const service = parts[1];
      const resolved = resolveConfig(`/${service}`);
      parts[1] = resolved;
      const Final_Url = parts.slice(1).join("/");

      // Cancel any existing connection
      if (controllerRef.current) controllerRef.current.abort();

      const controller = new AbortController();
      controllerRef.current = controller;

      fetchEventSource(Final_Url, {
        method: "GET",
        headers: { Authorization: `Bearer ${token}` },
        signal: controller.signal,

        async onopen(response) {
          // if (response.ok && response.status === 200) {
          //   console.log("SSE Connection established");
          //   setConnected(true);
          //   onOpen?.(response);
          // } else {
          //   console.error("SSE Connection failed:", response.status);
          // }
          if(response.status===401){
            const errorCode=
            response.headers.get("x-error-code")|| "SESSION_EXPIRED";

        if (
          errorCode === "CONCURRENT_LOGIN" ||
          errorCode === "SESSION_EXPIRED" ||
          errorCode === "INVALID_TOKEN"
        ) {
      // Do NOT attempt refresh. The session is dead.
      // We dispatch a custom event that AuthContext listens to for the Dialog
      dispatch(logoutSuccess());
      window.dispatchEvent(
        new CustomEvent("auth:session-expired", {
          detail: { reason: errorCode },
        })
      );
        controller.abort();
        return;
          }
if(errorCode==="TOKEN_EXPIRED"){
          if(!retryRef.current){
            retryRef.current=true;
            controller.abort();

            try{
              await refreshAccessToken(dispatch);
              startStream(url,{
                onMessage,
                onOpen,
                onError,
                onTaskProgress,
              });
            }
            catch(err){
              //dispatch(logoutSuccess());
            }
            return;
          }
        }}
          retryRef.current=false;
          setConnected(true);
          onOpen?.(response);

        },

        onmessage(event) {
          if (event.event === "connected") {
            // console.log("Server connected:", event.data);
            return;
          }

          // NOTIFICATIONS
          if (event.event === "new_notification") {
            try {
              const data = JSON.parse(event.data);
              setLastMessage(data);
              onMessage?.(data);
            } catch (err) {
              console.error("SSE notification parse error:", err);
            }
          }

          // TASK PROGRESS
          if (event.event === "task_progress") {
            try {
              const data = JSON.parse(event.data);
              onTaskProgress?.(data);
            } catch (err) {
              console.error("SSE task progress parse error:", err);
            }
          }
        },

        onerror(err) {
          console.error("SSE Error:", err);
          setConnected(false);
          onError?.(err);
        },
      });
    },
    [token]
  );

  const stopStream = useCallback(() => {
    if (controllerRef.current) {
      controllerRef.current.abort();
      controllerRef.current = null;
      setConnected(false);
      console.log("SSE connection stopped.");
    }
  }, []);

  useEffect(() => stopStream, [stopStream]);

  return { connected, lastMessage, startStream, stopStream };
};

export default useStreamApi;



